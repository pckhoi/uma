package uma

import (
	"net/http"
)

type ProviderGetter func(r *http.Request) Provider

type ResourceStore interface {
	Set(name, id string)
	Get(name string) (id string)
}

type resourceMiddleware struct {
	rm            *resourceMatcher
	getProvider   ProviderGetter
	resourceStore ResourceStore
	client        *http.Client
}

func (m *resourceMiddleware) createResource(p Provider, resource *Resource) (err error) {
	if s := m.resourceStore.Get(resource.Name); s != "" {
		resource.ID = s
		return nil
	}
	resourceID, err := p.CreateResource(resource)
	if err != nil {
		return err
	}
	m.resourceStore.Set(resource.Name, resourceID)
	resource.ID = resourceID
	return nil
}

type ResourceMiddlewareOptions struct {
	// ====== required fields ======

	// GetBaseURL returns the base url of the covered api. It is typically the "url" of the matching
	// server entry in openapi spec. It should have this format: "{SCHEME}://{PUBLIC_HOSTNAME}{ANY_BASE_PATH}"
	GetBaseURL URLGetter

	// GetProvider returns the provider info given the request. It allows you to use different UMA
	// providers for different requests if you so wish
	GetProvider ProviderGetter

	// ResourceStore persistently stores resource name and id. Some UMA providers don't like to be told
	// twice about the same resource. This tells the middleware which resource is already registered so
	// it doesn't have to be registered again.
	ResourceStore ResourceStore

	// Types maps resource type name to their description. Typically generated by uma-codegen
	Types map[string]ResourceType

	// ResourceTemplates are the template objects to generate resource object on the fly. Typically generated
	// by uma-codegen
	ResourceTemplates ResourceTemplates

	// ====== optional fields ======

	// Client is the http client that the middlewares can use to communicate with UMA providers. Defaults to
	// http.DefaultClient
	Client *http.Client
}

// ResourceMiddleware detects UMAResource by matching request path with paths. types is the map between
// resource type and UMAResourceType. paths is the map between path template and resouce type as defined
// in OpenAPI spec.
func ResourceMiddleware(opts ResourceMiddlewareOptions) func(next http.Handler) http.Handler {
	rm := newResourceMatcher(opts.GetBaseURL, opts.Types, opts.ResourceTemplates)
	m := &resourceMiddleware{
		rm:            rm,
		getProvider:   opts.GetProvider,
		resourceStore: opts.ResourceStore,
		client:        http.DefaultClient,
	}
	if opts.Client != nil {
		m.client = opts.Client
	}
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			var resource *Resource
			r, resource = m.rm.match(r)
			if resource != nil {
				if err := m.createResource(m.getProvider(r), resource); err != nil {
					panic(err)
				}
			}
			next.ServeHTTP(w, r)
		})
	}
}
